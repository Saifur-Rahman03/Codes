# -*- coding: utf-8 -*-
"""Genetic Algorithm CT #4 Assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h_eF-h3rhCTOwweVum9JkV6lltf7_jVz

"""

import random

# Genetic Algorithm parameters
chromosome_length = 20
population_size = 30
num_generations = 10

"""Fitness Function"""

def fitness_function(chromosome):
    decimal_value = int(chromosome, 2)  # Convert binary string to decimal
    return decimal_value

"""Generate Initial Population"""

def generate_population():
    population = []
    for _ in range(population_size):
        chromosome = ''.join(random.choice(['0', '1']) for _ in range(chromosome_length)) # generate random chromosome
        population.append(chromosome)
    return population

"""Roulette Wheel Selection"""

def selection(population):
    total_fitness = sum(fitness_function(chromosome) for chromosome in population)
    probabilities = [fitness_function(chromosome) / total_fitness for chromosome in population]
    selected = random.choices(population, probabilities, k=2) # select 2 chromosome randomly by using probabilities
    return selected[0], selected[1]

"""Single-Point Crossover"""

def crossover(parent1, parent2):
    crossover_point = random.randint(1, chromosome_length - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

"""Bit Flip Mutation"""

def mutation(chromosome, mutation_rate):
    mutated_chromosome = ''
    for bit in chromosome:
        if random.random() < mutation_rate:
            mutated_chromosome += '0' if bit == '1' else '1' # inverted
        else:
            mutated_chromosome += bit # unchanged
    return mutated_chromosome

"""Each Generation Efficiency Calculation"""

def calculate_efficiency(population):
    return min(fitness_function(chromosome) for chromosome in population)

"""Genetic Algorithm"""

def genetic_algorithm():

    # generate random population
    population = generate_population()
    print("Initial Population:")

    # print population with fitness values
    for chromosome in population:
        print(chromosome, fitness_function(chromosome))
    print()
    
    minimum_number = float('inf')
    best_chromosome = None

    for generation in range(num_generations):
        new_population = []

        for _ in range(population_size // 2): # no of parent pair
            parent1, parent2 = selection(population) # selection
            child1, child2 = crossover(parent1, parent2) # crossover
            child1 = mutation(child1, mutation_rate=0.01) # mutation
            child2 = mutation(child2, mutation_rate=0.01) # mutation
            new_population.extend([child1, child2])

        population = new_population

        print("Generation", generation + 1)
        for chromosome in population:
            fitness = fitness_function(chromosome)
            print(chromosome, fitness) # fitness value
            if fitness < minimum_number:
                minimum_number = fitness
                best_chromosome = chromosome

        print("Efficiency:", calculate_efficiency(population)) # efficiency of current generation
        print()
        
    print("Minimum Number:", minimum_number)
    print("Best Chromosome:", best_chromosome)

genetic_algorithm()



