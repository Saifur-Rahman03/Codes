# -*- coding: utf-8 -*-
"""Kohonen algorithm

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u0oP-dmKW1Wm_OFqpWqM9AGo2GBU68q7
"""

import pandas as pd
import random
import math
import numpy as np

"""# Input

Input data
"""

pattern = 100
feat = 10
def pattern_generation(pattern, feat):
  x = []
  for i in range(pattern):
      example = [random.randint(0, 1) for j in range(feat)]
      x.append(example)
  return x

x = pattern_generation(pattern, feat)
lr = 0.1 # learning rate
num_neighborhood = 5 # neighborhood size
print(x)

"""# Functions

Input weights
"""

def initialize_weight():
  rows, cols = (feat, pattern)
  w = [[0] * cols] * rows
  for i in range(0, rows):
    for j in range(0, cols):
      w[i][j] = round(random.uniform(0, 1), 2)
  return w

"""Calculate distance"""

def calculate_distance(x, w):
  d = [0] * pattern
  for j in range(0, pattern):
    sum = 0
    for i in range(0, feat):
      sum = sum + (x[j][i] - w[i][j])**2
    d[j] = sum
  return d

"""Calculate distance for new patterns"""

def calculate_distance_new(p, w, new_pattern):
  d = [0] * pattern
  for j in range(0, pattern):
    sum = 0
    for i in range(0, feat):
      sum = sum + (p[i] - w[i][j])**2
    d[j] = sum
  return d

"""sorted distance"""

def sort_distance(d):
  sorted_d = sorted(enumerate(d), key=lambda x:x[1])
  sorted_values = [x[1] for x in sorted_d]
  sorted_indices = [x[0] for x in sorted_d]
  return sorted_values, sorted_indices

"""Update weight"""

def update_weight(w, num_neighborhood, sorted_indices):
  for i in range(0, feat):
    for j in range(0, int(num_neighborhood)):
      k = sorted_indices[j]
      w[i][k] = w[i][k] + lr * (x[j][i] - w[i][k])
  return w

"""Check for break condition"""

def break_loop_for_weight(w, prev_w):
  dw = [[0] * pattern] * feat
  for i in range(0, feat):
    for j in range(0, pattern):
      dw[i][j] = abs(w[i][j] - prev_w[i][j])
  for i in range(0, feat):
    for j in range(0, pattern):
      if(dw[i][j] < 0.0001):
        dw[i][j] = 0
  sum = 0
  for i in range(0, feat):
    for j in range(0, pattern):
      sum = sum + dw[i][j]
  return sum

"""# Implementation

Learning
"""

w = initialize_weight()
while True:
  d = calculate_distance(x, w)
  prev_w = w.copy()
  sorted_values, sorted_indices = sort_distance(d)
  
  num_neighborhood = num_neighborhood - lr * num_neighborhood
  if(num_neighborhood <= 1):
    break  
  
  w = update_weight(w, num_neighborhood, sorted_indices)
  
  sum = break_loop_for_weight(w, prev_w)
  if sum == 0:  
    break

"""Outsiders"""

new_pattern = 10
y = pattern_generation(new_pattern, feat)
print(y)

"""Similarity Checking"""

i = 0
center = 10
print("new pattern\tsimilar with")
print("----------------------------")
for p in y:
  i = i + 1
  d_new = calculate_distance_new(p, w, new_pattern)
  sorted_values, sorted_indices = sort_distance(d_new)
  print(str(i).center(center),'\t', str(sorted_indices[0] + 1).center(center))

