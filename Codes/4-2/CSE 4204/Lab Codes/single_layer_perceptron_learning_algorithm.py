# -*- coding: utf-8 -*-
"""5 Bit Single Layer Perceptron Learning Algorithm

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Eu_BedRYmWegF-ezSyp1PfqhKSBq5si

# Imports
"""

import pandas as pd
import math

"""# Function Definition

Accuracy Calculation
"""

def accuracy(result, origin):
  matched = 0
  non_matched = 0
  for i in range(0, len(result)):
    if result[i] == origin[i]:
      matched = matched + 1
    else:
      non_matched = non_matched + 1
  acc = (matched / (matched + non_matched)) * 100
  print('Accuracy: ', round(acc, 2), '%')

"""# Input Data"""

# input
x1 = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
x2 = [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]
x3 = [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]
x4 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
x5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
# weight
w = [0.1, 0.3, 0.2, 0.3, 0.4]
# output
y = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
# thresholding function
T = 0.5

"""Dataframe Definition"""

df = pd.DataFrame(list(zip(x5, x4, x3, x2, x1, y)), columns = ['x5', 'x4', 'x3', 'x2', 'x1', 'y'])
test_df = df.copy() # copied dataframe for accuracy calculation
df2 = df.copy()
l = len(df)
b = 5 # no of inputs/ index of class
percentage = 60 # percentage of training data
df

"""# Training

Training & Testing Data
"""

train = math.ceil(l * (percentage / 100)) # no of training data
test = l - train # no of testing data
print(train, test)

"""Learning"""

n = 50 # no of times loop will run
act_y = [0] * (n + 1)
it = 0 # no of iteration
i = 0 # loop iterator

while True:
  it = it + 1
  if i >= train:    # iterate through only train data
    i = 0

  sop = 0
  for k in range(b):
    sop = sop + (df.iloc[i, b - 1 - k] * w[k])
  

  # actual output according to the thresholding function
  if sop >= T:
    act_y[i] = 1
  else:
    act_y[i] = 0 

  # actual and desired output comparison
  if act_y[i] == df.loc[i, 'y']:  # desired and actual matched
    i = i + 1                     # no change in weight
  else:
    if df.loc[i, 'y'] == 1 and act_y[i] == 0:     # desired 1, actual 0
      for j in range(0, len(w)):                  
        w[j] = w[j] + df.iloc[i, len(w) - 1 - j]  # add input to weight
      i = 0                                       # startover
    else:                                         # desired 0, actual 1
      for j in range(0, len(w)):
        w[j] = w[j] - df.iloc[i, len(w) - 1 - j]  # subtract input from weight
      i = 0                                       # startover

  if it > n : # loop runs n + 1 times
    break

print('Adapted weight:', w)
print('no of iterations: ', it)

"""# Testing"""

# desired output
origin = df.loc[train:, 'y'].values.tolist()
print(origin)

# actual output 
result = []
for i in range(train, len(df)):

  sop = 0
  for k in range(b):
    sop = sop + (df.iloc[i, b - 1 - k] * w[k])
  
  if sop >= T:
    result.append(1)
  else:
    result.append(0)
print(result)

"""Accuracy Calculation type1"""

accuracy(result, origin)

"""# Type - 2"""

n = 50 # no of times loop will run
act_y = [0] * (n + 1)
it = 0 # no of iteration
i = 0 # loop iterator

while True:
  it = it + 1
  if i >= train:    # iterate through only train data
    if i > (train / 2):
        i = math.ceil(train / 2)
    else:
        i = 0
  for k in range(b):
    sop = sop + (df.iloc[i, b - 1 - k] * w[k])

  # actual output according to the thresholding function
  if sop >= T:
    act_y[i] = 1
  else:
    act_y[i] = 0 

  # actual and desired output comparison
  if act_y[i] == df2.loc[i, 'y']:  # desired and actual matched
    i = i + 1                     # no change in weight
  else:
    if df2.loc[i, 'y'] == 1 and act_y[i] == 0:     # desired 1, actual 0
      for j in range(0, len(w)):                  
        w[j] = w[j] + df2.iloc[i, len(w) - 1 - j]  # add input to weight
      
      if i > (train / 2):
        i = math.ceil(train / 2)
      else:
        i = 0                                       # startover
    else:                                         # desired 0, actual 1
      for j in range(0, len(w)):
        w[j] = w[j] - df2.iloc[i, len(w) - 1 - j]  # subtract input from weight
      if i > (train / 2):
        i = math.ceil(train / 2)
      else:
        i = 0                                     # startover

  if it > n : # loop runs n + 1 times
    break

print('Adapted weight:', w)
print('no of iterations: ', it)

# actual output type2 
result2 = []
for i in range(train, len(df2)):
  sop = 0
  for k in range(b):
    sop = sop + (df.iloc[i, b - 1 - k] * w[k])
  if sop >= T:
    result2.append(1)
  else:
    result2.append(0)
print(result2)

"""Accuracy calculation type 2"""

accuracy(result2, origin)