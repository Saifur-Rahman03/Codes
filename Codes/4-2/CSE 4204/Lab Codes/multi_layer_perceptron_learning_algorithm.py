# -*- coding: utf-8 -*-
"""Multi-layer Perceptron Learning Algorithm

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1THGqlQpXK1Bqb-4FUKBFonJJsGdL3v7x
"""

import pandas as pd
import random
import math
import numpy as np

"""# Input Data"""

# Input
x1 = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
x2 = [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1]
x3 = [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]
x4 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
x5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]

# Output
y = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 1, 1]

df = pd.DataFrame(list(zip(x5, x4, x3, x2, x1, y)), columns = ['x5', 'x4', 'x3', 'x2', 'x1', 'y'])
data = df.values.tolist()
print(data)

num_rows = len(data)
num_cols = len(data[0]) - 1
num_unique_values = len(set(y))
print("Number of persons:", num_rows)
print("Number of features:", num_cols)
print("Number of classes:", num_unique_values)

"""Neural Network Definition"""

# input node = 5
inp = 5
hid = 2 # hidden node = 2
out = 3 # output node = 3 : no of classes = 5 - 8

k1 = 1
k2 = 1
N1 = 1
N2 = 1

"""Thresholding functions"""

uh = [0.4, 0.3] # thresholding function
uo = [0.1, 0.3, 0.2] # thresholding function

"""Weights

Wij
"""

rows, cols = (inp, hid) # input 5, hidden 2
w1 = [[0] * cols] * rows
for i in range(0, rows):
  for j in range(0, cols):
    w1[i][j] = round(random.uniform(0, 1), 2)
print(w1)

"""Wjk"""

rows, cols = (hid, out) # hidden 2, output 3
w2 = [[0] * cols] * rows
for i in range(0, rows):
  for j in range(0, cols):
    w2[i][j] = round(random.uniform(0, 1), 2)
print(w2)

"""# Functions"""

def initialization():
  rows, cols = (inp, hid) # input 5, hidden 2
  for j in range(0, cols):
      uh[j] = round(random.uniform(0, 1), 2)
  w1 = [[0] * cols] * rows
  for i in range(0, rows):
    for j in range(0, cols):
      w1[i][j] = round(random.uniform(0, 1), 2)
  #print(w1)
  rows, cols = (hid, out) # hidden 2, output 3
  for j in range(0, cols):
      uo[j] = round(random.uniform(0, 1), 2)
  w2 = [[0] * cols] * rows
  for i in range(0, rows):
    for j in range(0, cols):
      w2[i][j] = round(random.uniform(0, 1), 2)
  #print(w2)
  return w1, w2, uh, uo

def outputCalculation1(layer1, layer2, input, thres, weight, k):
  rows, cols = (layer1, layer2)
  net = [0] * cols
  sop = 0
  for j in range(0, cols):
    sop = 0
    for i in range(len(input) - 1):
      sop = sop + weight[i][j] * input[i]
    net[j] = sop

  activ = [0] * cols
  for j in range(0, cols):
    activ[j] = net[j] + thres[j]

  Output = [0] * cols
  k = 1 # spread factors
  for j in range(0, cols):
    Output[j] = 1 / ( 1 + math.exp(-1 * k * activ[j]))

  return Output

def outputCalculation2(layer1, layer2, input, thres, weight, k):
  rows, cols = (layer1, layer2)
  net = [0] * cols
  sop = 0
  for j in range(0, cols):
    sop = 0
    for i in range(0, rows):
      sop = sop + weight[i][j] * input[i]
    net[j] = sop

  activ = [0] * cols
  for j in range(0, cols):
    activ[j] = net[j] + thres[j]

  Output = [0] * cols
  k = 1 # spread factors
  for j in range(0, cols):
    Output[j] = 1 / ( 1 + math.exp(-1 * k * activ[j]))

  return Output

def adjustOutputWeights(layer1, layer2, Output1, Output2, error, Weight, N, k):
  rows, cols = (layer1, layer2)
  delW = [[0] * cols] * rows
  for j in range(0, rows):
    for k in range(0, cols):
      delW[j][k] = N2 * k2 * error[k] * Output1[j] * Output2[k] * (1 - Output2[k])
      Weight[j][k] = Weight[j][k] + delW[j][k]
  return Weight

def adjustOutputThres(layer, Output, error, thres, N, k):
  cols = layer
  delu = [0] * cols
  for k in range(0, cols):
    delu[k] = N2 * k2 * error[k] * Output[k] * (1 - Output[k])
    thres[k] = thres[k] + delu[k]
  return thres

def adjustHiddenWeights(layer1, layer2, layer3, Output, Output1, error, W1, W2, N, k):
  rows, cols, hd = (layer1, layer2, layer3)
  delW = [[0] * cols] * rows
  for i in range(0, rows):
    for j in range(0, cols):
      sop = 0
      for k in range(0, hd):
        sop = sop + W2[j][k] * error[k]
      delW[i][j] = N1 * k1  * O[i] * O1[j] * (1 - O1[j]) * sop
      W1[i][j] = W1[i][j] + delW[i][j]
  return W1

def adjustHiddenThres(layer1, layer2, Output, error, W, thres, N, k):
  rows, cols = (layer1, layer2)
  delu = [0] * rows
  for j in range(0, rows):
    sop = 0
    for k in range(0, cols):
      sop = sop + W[j][k] * error[k]
    delu[j] = N1 * k1  * Output[j]  * (1 - Output[j]) * sop
    thres[j] = thres[j] + delu[j]
  return thres

def sigma(layer, desired, actual):
  sig = [0] * layer
  for k in range(0, layer):
    sig[k] = abs(desired[k] - actual[k])
  return sig

def error(layer, desired, actual):
  for k in range(0, layer):
    sum = 0
    sum = sum + abs((desired[k] - actual[k])**2)
  Error = 0.5 * sum
  return Error

"""# Algorithm

Initialization
"""

w1, w2, uh, uo = initialization()

"""Train-Test Splitting"""

p = 40
m = math.ceil((len(data) * p / 100))
train = [row[:] for row in data[:m]]
test = [row[:] for row in data[m:]]
O = train[0]
T = [row[5] for row in data[:m]]

"""Input for hidden layer"""

O1 = outputCalculation1(inp, hid, O, uh, w1, k1)
print(O1)

"""Input for output layer"""

#O2 = [0] * out
O2 = outputCalculation2(hid, out, O1, uo, w2, k2)
print(O2)

"""Error Calculation"""

sig = sigma(out, T, O2)
print(sig)

"""New Output Weights"""

w2 = adjustOutputWeights(hid, out, O1, O2, sig, w2, N2, k2)
print(w2)

"""New Output Thresholds"""

uo = adjustOutputThres(out, O2, sig, uo, N2, k2)
print(uo)

"""New Hidden Weights"""

w1 = adjustHiddenWeights(inp, hid, out, O, O1, sig, w1, w2, N1, k1)
print(w1)

"""New Hidden Thresholds"""

uh = adjustHiddenThres(hid, out, O1, sig, w2, uh, N1, k1)
print(uh)

"""Final Error"""

Error = error(out, T, O2)
print(Error)

"""# Training & Testing"""

train = []
test = []
P = [50, 60, 70, 80, 90] # training percentage

print("Training(%)\tAccuracy(%)")
print("---------------------------")
center = 7
for p in P:

# Training
  m = math.ceil((len(data) * p / 100))
  train = [row[:] for row in data[:m]]
  test = [row[:] for row in data[m:]]
  T = [row[5] for row in data[:m]]

  while(i < m):
    O = train[i]
    
    w1, w2, uh, uo = initialization()
    O1 = outputCalculation1(inp, hid, O, uh, w1, k1)
    O2 = outputCalculation2(hid, out, O1, uo, w2, k2)
    sig = sigma(out, T, O2)
    w2 = adjustOutputWeights(hid, out, O1, O2, sig, w2, N2, k2)
    uo = adjustOutputThres(out, O2, sig, uo, N2, k2)
    w1 = adjustHiddenWeights(inp, hid, out, O, O1, sig, w1, w2, N1, k1)
    uh = adjustHiddenThres(hid, out, O1, sig, w2, uh, N1, k1)
    E = error(out, T, O2)
    
    if(E < 0.33): 
        i = i + 1
    else:
        i = 0
        continue
# Testing
  c = 0
  for t in test:
    O1 = outputCalculation1(inp, hid, t, uh, w1, k1)
    O2 = outputCalculation2(hid, out, O1, uo, w2, k2)

    if(t[-1]==np.round(O2[0])):
          c = c + 1

  print(str(p).center(center),'\t', str(round(c/len(test)*100.0, 2)).center(center))

